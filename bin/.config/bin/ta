#!/usr/bin/env luajit

-- Helper to run command and capture output
local function exec_capture(cmd)
	local handle = io.popen(cmd)
	local result = handle:read("*a")
	handle:close()
	return result
end

-- Helper to run command and return status
local function exec(cmd)
	local status = os.execute(cmd)
	-- LuaJIT os.execute returns the exit status directly
	return status
end

local function list_git_directories()
	-- Set your base directory
	local ROOT_DIR = os.getenv("HOME") .. "/workspace"
	local results = {}

	-- Function to execute a command and return output lines as a table
	local function execute_and_collect(command)
		local lines = {}
		local handle = io.popen(command, "r")
		if handle then
			for line in handle:lines() do
				lines[#lines + 1] = line
			end
			handle:close()
		end
		return lines
	end

	--- 1. Find and process standard (non-bare) repositories ---
	local find_dirs_cmd = string.format("fd --type d --hidden --no-ignore-vcs --base-directory %s", ROOT_DIR)

	for _, dir in ipairs(execute_and_collect(find_dirs_cmd)) do
		if not dir:match("/%.git$") then
			local is_std_repo_cmd = string.format('[[ -d "%s/.git" ]] && ! [[ -f "%s/.git" ]] && echo "Y"', dir, dir)
			if execute_and_collect(is_std_repo_cmd)[1] == "Y" then
				-- Standard repos are listed as just their path
				results[#results + 1] = dir
			end
		end
	end

	--- 2. Find and process bare repositories and their worktrees ---
	local find_bare_repos_cmd =
		string.format('fd --type d --hidden --no-ignore-vcs --base-directory %s | grep "/\\.git$"', ROOT_DIR)

	for _, bare_repo in ipairs(execute_and_collect(find_bare_repos_cmd)) do
		local is_bare_cmd =
			string.format('git -C "%s" rev-parse --is-bare-repository > /dev/null 2>&1 && echo "Y"', bare_repo)

		if execute_and_collect(is_bare_cmd)[1] == "Y" then
			-- Print the bare repository path itself (unformatted)
			results[#results + 1] = bare_repo

			-- Get the detailed porcelain output for worktrees
			local worktree_porcelain_cmd = string.format('git -C "%s" worktree list --porcelain 2>/dev/null', bare_repo)
			local worktree_output = execute_and_collect(worktree_porcelain_cmd)

			local current_path = nil
			local current_branch = nil

			-- Process the porcelain output block by block
			for _, line in ipairs(worktree_output) do
				if line:match("^worktree ") then
					-- Found a new worktree path
					current_path = line:match("^worktree (.*)$")
					current_branch = nil -- Reset branch for the new block
				elseif line:match("^branch ") and current_path then
					-- Found the branch for the current worktree
					-- Extracts the branch name, e.g., refs/heads/main -> main
					current_branch = line:match("refs/heads/(.*)$")
				elseif line == "" and current_path then
					-- End of a worktree block, process and format the result
					local formatted_path = current_path
					if current_branch then
						-- Format as (<branch>) <path>
						formatted_path = string.format("(%s) %s", current_branch, current_path)
					end
					results[#results + 1] = formatted_path

					-- Reset for the next block
					current_path = nil
					current_branch = nil
				end
			end
		end
	end

	return results
end

-- Check if in tmux
local function not_in_tmux()
	return os.getenv("TMUX") == nil
end

local dir = arg[1]

-- If no arguments, try to attach or default to --start
if not dir or dir == "" then
	if not_in_tmux() then
		if exec("tmux attach") == 0 then
			os.exit(1)
		else
			dir = "--start"
		end
	else
		os.exit(1)
	end
end

local session_name = ""
local path_name = ""

if dir == "--start" then
	print("starting")
	-- path_name="$(basename "$PWD" | tr . -)"
	local pwd = os.getenv("PWD")
	local basename = pwd:match("^.+/(.+)$") or pwd
	path_name = basename:gsub("%.", "-")

	-- session_name=${path_name//./_}
	session_name = path_name:gsub("%.", "_")
else
	-- ask user
	-- Use < /dev/tty to ensure fzf gets user input
	local cmd =
		string.format('list-workspaces | fzf --reverse --header="Select project from $(basename %s) >"', dir, dir)
	local _session_name = exec_capture(cmd):gsub("\n", "")

	-- session_name=${_session_name//./_}
	session_name = _session_name:gsub("%.", "_")

	-- path_name=$DIR/$session_name
	path_name = dir .. "/" .. session_name
end

print('session name is "' .. session_name .. '"')
print("path name is " .. path_name)

if session_name == "" then
	-- operation cancelled by user
	os.exit(1)
end

local function session_exists()
	-- tmux has-session -t "=$session_name"
	return exec('tmux has-session -t "=' .. session_name .. '"') == 0
end

local function create_detached_session()
	local tmux_cmd_prefix = "TMUX='' tmux"

	if dir == "--start" then
		local cmd = string.format('%s new-session -Ad -s "%s" -c "%s"', tmux_cmd_prefix, session_name, path_name)
		exec(cmd)
	else
		local cmd1 = string.format('%s new-session -Ad -s "%s" -c "%s"', tmux_cmd_prefix, session_name, path_name)
		-- using ; to separate commands in os.execute might be cleaner than two exec calls if we want atomicity,
		-- but two calls is fine and matches script flow.
		exec(cmd1)

		local cmd2 = string.format('tmux send-keys -t "%s" "nvim" Enter', session_name)
		exec(cmd2)
	end
end

local function create_if_needed_and_attach()
	if not_in_tmux() then
		local cmd = string.format('tmux new-session -As "%s" -c "%s"', session_name, path_name)
		return exec(cmd) == 0
	else
		if not session_exists() then
			create_detached_session()
		end
		local cmd = string.format('tmux switch-client -t "%s"', session_name)
		return exec(cmd) == 0
	end
end

local function attach_to_first_session()
	-- bash: tmux attach -t $(tmux list-sessions -F "${session_name}" | head -n 1)
	-- Fixed to use #{session_name} to actually find a session if logic failed
	local cmd_list = 'tmux list-sessions -F "#{session_name}" | head -n 1'
	local target = exec_capture(cmd_list):gsub("\n", "")
	if target ~= "" then
		exec('tmux attach -t "' .. target .. '"')
		exec("tmux choose-tree -Za")
	end
end

if not create_if_needed_and_attach() then
	attach_to_first_session()
end
