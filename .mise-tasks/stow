#!/usr/bin/env python3
#MISE description="Symlink dotfiles"
#USAGE arg "[modules]" var=#true

import os
import sys
import subprocess
import pathlib

def log_info(msg):
    print(f"[\033[32mINFO\033[0m] {msg}")

def log_warn(msg):
    print(f"[\033[33mWARN\033[0m] {msg}")

def log_error(msg):
    print(f"[\033[31mERROR\033[0m] {msg}")

os_name = "darwin" if sys.platform == "darwin" else "linux"

platform_filters = {
    "darwin": {"xmodmap", "xmonad", "xorg"},
    "linux": set(),
}.get(os_name, set())

usage_modules = os.environ.get("usage_modules", "")
to_link = []

# Parse arguments
args = usage_modules.split()

if args:
    # Use provided arguments
    for dir_name in args:
        path = pathlib.Path(dir_name)
        if path.is_dir():
            if dir_name in platform_filters:
                log_warn(f"'{dir_name}' doesn't work for this platform: {os_name}")
            else:
                to_link.append(dir_name)
        else:
            # Check if it exists at all
            if path.exists():
                log_warn(f"'{dir_name}' is not a directory. Skipping.")
            else:
                log_warn(f"'{dir_name}' module doesn't exist. Skipping.")
else:
    # Default to all non-hidden directories except 'scripts' and '.mise-tasks'
    # Sort for deterministic behavior
    for path in sorted(pathlib.Path(".").iterdir()):
        if path.is_dir():
            dir_name = path.name
            if not dir_name.startswith(".") and dir_name not in {"scripts", ".mise-tasks"} and dir_name not in platform_filters:
                to_link.append(dir_name)

if not to_link:
    log_info("No modules to link")
    sys.exit(0)

log_info("Action = link (fling)")
for dir_name in to_link:
    log_info(f"  - {dir_name}")
    cmd = ["fling", "link", "--src-dir", dir_name, "--ask", "false"]
    try:
        subprocess.run(cmd, check=True)
    except subprocess.CalledProcessError:
        log_error(f"Failed to link {dir_name}")

# vim: ft=python
